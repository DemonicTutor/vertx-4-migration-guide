=== HTTP Client

The Vert.x HTTP client API has been rewritten in Vert.x 4. We can distinguish two kind of use cases for the HTTP client:

HTTP oriented applications (like REST), encoding and decode HTTP payloads, interpreting the
HTTP status response code, etc... Such applications should use instead the Vert.x Web Client that
provides a client API for such use cases.

HTTP proxy application (like an API gateway), acting as a man in the middle (like a reverse proxy).
Such applications should continue using the HTTP client and migrate to the new API. The Vert.x
HTTP client has been greatly improved in Vert.x 4 to make writing such use case easier.

NOTE: Vert.x Web Client is written on top of Vert.x HTTP Client

==== Migrating to Web Client

The Web Client is available in Vert.x 3 since Vert.x 3.4.0. The API remains the same between
Vert.x 3 and Vert.x 4.

todo.

==== Migrating to the new HTTP Client

The HTTP client API has been greatly improved in Vert.x 4

- simplified API with only a few interactions
- robust error handling
- support for request reset for HTTP/1 as best effort

Here are the important API changes that you will face

- the HTTP client provides only a single `request` method instead of `get`, `post`, etc...
- `HttpClientRequest` are not lazily created anymore, you will get an `HttpClientRequest` when a request/response is possible,
e.g you need for the client to connect to the server or reuse a connection from the pool

===== Dealing with a simple request

Here is how can you perform an GET request

```java
// Vert.x 3
HttpClientRequest request = client.get(80, "example.com", "/", response -> {
  int statusCode = response.statusCode();
  response.exceptionHandler(err -> {
    // Handle connection error, e.g connection closed
  });
  response.bodyHandler(body -> {
    // Handle body entirely
  });
});
request.exceptionHandler(err -> {
  // Handle connection error OR response error
});
request.end();

// Vert.x 4
client.request(HttpMethod.GET, 80, "example.com", "/", ar -> {
  if (ar.succeeded()) {
    HttpClientRequest = ar.result();
    request.send(ar2 -> {
      if (ar2.succeeded()) {
        HttpClientResponse = ar2.result();
        int statusCode = response.statusCode();
        response.body(ar3 -> {
          if (ar3.succeeded()) {
            Buffer body = ar3.result();
            // Handle body entirely
          } else {
            // Handle server error, e.g connection closed
          }
        });
      } else {
        // Handle server error, e.g connection closed
      }
    });
  } else {
    // Deal connection error, e.g the invalid server or invalid SSL certificate
  }
});
```

This seems more verbose at the first sight, but we can see that error handling is more natural
in the new version.

This example can be simplified using future with composition

```java
// Vert.x 4
Future<Buffer> fut = client.request(HttpMethod.GET, 80, "example.com", "/")
  .compose(request -> request.send().compose(response -> {
    int statusCode = response.statusCode();
    if (statusCode == 200) {
      return response.body();
    } else {
      return Future.failedFuture("Unexpectd status code");
    }
  })
});
fut.onComplete(ar -> {
  if (ar.succeeded()) {
    Buffer body = ar.result();
    // Handle body entirely
  } else {
    // Handle error
  }
});
```

This example uses future composition that are very good at improving the flow, in particular
exception handling. The new example now checks that the status code is 200 otherwise returns an error.

WARNING: using the client with futures should respect a few key rules. Indeed an `HttpClientResponse`
will start emitting buffers as soon as it is received, so the composition should either happen on the event-loop
like in the example above or it should `pause`/`resume` the response

===== Request streaming

todo.

===== Response streaming

todo.